#!/usr/bin/env python3

import re
import sys, os
import shutil
import argparse
import progressbar
import pandas as pd
from glob import glob
from termcolor import colored
from collections import namedtuple

# =================================================================================================
#     Command Line Interface
# =================================================================================================

# CLI parsing setup
parser = argparse.ArgumentParser(description=
    "Tool to copy or symlink the fastq files as provided in a samples table of grenepipe, "
    "while also allowing to clean up invalid file names, and generating a new samples table "
    "containing the paths to the new fastq files. Note that all files are copied/linked to "
    "one target directory, independently of whether they were originally in different ones."
)

# Required arguments
parser.add_argument(
    '--samples-table',
    required=True,
    help="The samples table as generated by the `generate-table.py` script. "
         "The samples in this table are the ones copied/linked."
)
parser.add_argument(
    '--out-dir',
    required=True,
    help="The target directory where to copy/link the samples to."
)

# Optional arguments
parser.add_argument(
    '--clean', action='store_true',
    help="By default, we use sample names and fastq file names as they are. With this option "
         "however, we clean the sample names and file names, by replacing characters that "
         "might cause trouble with underscores. Only a-z, A-Z, 0-9, `-`, `_`, `.` are kept, "
         "and everything else is replaced by underscores. "
         "Only affects sample and file names, not their paths."
)
parser.add_argument(
    '--mode', choices=['copy', 'link'], default='copy',
    help="By default, we copy the sample fastq to the `--out-dir`. "
         "With this option, the fastq files can be sym-linked instead."
)
parser.add_argument(
    '--out-samples-table',
    help="By default, we produce a new samples table containing the new names and paths, "
         "using the name `samples-copied.tsv` for an input --samples-table `samples.tsv`, "
         "in the same directory as the original table. "
         "Use this option to instead provide a different path/name for this new table."
)

# =================================================================================================
#     Functions
# =================================================================================================

# We want nicer data access than just addressing matches by tuple indices.
# It represents one row of the samples table, with its old and new names / file paths.
# We cannot use namedtuple here, as we want it to be mutable... Python being weird there...
class Sample:
    __slots__ = [
        'old_name', 'new_name', 'unit', 'platform', 'old_fq1', 'new_fq1', 'old_fq2', 'new_fq2'
    ]
    def __init__( self, old_name, unit, platform, old_fq1, old_fq2 ):
        self.old_name = old_name
        self.unit = unit
        self.platform = platform
        self.old_fq1 = old_fq1
        self.old_fq2 = old_fq2

def file_size_human_readable(bytes, units=[' bytes','KB','MB','GB','TB', 'PB', 'EB']):
    """ Returns a human readable string representation of bytes """
    # https://stackoverflow.com/a/43750422/4184258
    return str(bytes) + units[0] if bytes < 1024 else file_size_human_readable(bytes>>10, units[1:])

def yes_or_no(question):
    while True:
        reply = str(input(question+' (y/n): ')).lower().strip()
        if len(reply):
            if reply[0] == 'y':
                return True
            if reply[0] == 'n':
                return False

def read_samples_table( path ):
    if not os.path.exists(path):
        raise Exception("Samples table " + path + " not found.")
    df = pd.read_csv(path, sep='\t', dtype=str)
    table = []
    for index, row in df.iterrows():
        line = Sample(
            old_name=row["sample"], unit=row["unit"], platform=row["platform"],
            old_fq1=row["fq1"], old_fq2=(row["fq2"] if not pd.isnull(row["fq2"]) else "")
        )
        table.append(line)
    return table

# Helper to check if a file path contains weird characters.
def valid_filepath( fn ):
    # Only accept alnum, underscore, dash, dot, and slashes.
    clean = fn.replace('_', '').replace('-', '').replace('.', '').replace('/', '').replace('\\', '')
    return clean.isalnum() and clean.isascii()

def clean_filename( fn ):
    # Replace all invalid characters by underscores
    if any(c == '/' or c == '\\' for c in fn):
        raise Exception( "Internal error: Trying to use a path as a file." )
    return re.sub('[^a-zA-Z0-9\\.\\-_]', '_', fn)

def process_samples_table_names( table, args ):
    sample_units = list()
    file_list = list()
    invalid_samples = 0
    invalid_files = 0
    for line in table:
        # Get the original names and paths
        sample = line.old_name
        head_fq1, tail_fq1 = os.path.split( line.old_fq1 )
        head_fq2, tail_fq2 = os.path.split( line.old_fq2 )

        # Build the new sample and file names
        if args.clean:
            sample = clean_filename( sample )
            tail_fq1 = clean_filename( tail_fq1 )
            tail_fq2 = clean_filename( tail_fq2 )
        line.new_name = sample
        line.new_fq1 = os.path.join( args.out_dir, tail_fq1 )
        if len(tail_fq2) > 0:
            line.new_fq2 = os.path.join( args.out_dir, tail_fq2 )
        else:
            line.new_fq2 = ""

        # Count the still invalid names. Can only happen without --clean
        if not valid_filepath( sample ):
            invalid_samples += 1
        if not valid_filepath( tail_fq1 ):
            invalid_files += 1
        if len(tail_fq2) > 0 and not valid_filepath( tail_fq2 ):
            invalid_files += 1

        # Output file checks
        if len(line.new_fq1) == 0:
            raise Exception(
                "Empty fq1 file path for sample " + str(sample) + " " + str(line.unit) + "; " +
                "we only allow fq2 to be empty for single end reads, but not fq1. Please fix."
            )
        if os.path.exists( line.new_fq1 ):
            raise Exception(
                "New fastq file path already exists: " + line.new_fq1 + "; will not overwrite."
            )
        if len(line.new_fq2) > 0 and os.path.exists( line.new_fq2 ):
            raise Exception(
                "New fastq file path already exists: " + line.new_fq2 + "; will not overwrite."
            )

        # Safety checks
        if ( sample, line.unit ) in sample_units:
            raise Exception(
                "Identical sample name and unit created in samples table after processing: " +
                str(sample) + " " + str(line.unit) + ". This means that names only differed in " +
                "their special characters, or were already identical beforehand. Please fix manually."
            )
        if line.new_fq1 in file_list:
            raise Exception(
                "Identical fastq file paths created in samples table after processing: " +
                str(line.new_fq1) + "; this means that names only differed in their " +
                "special characters, or were already identical beforehand. Please fix manually."
            )
        if len(line.new_fq2) > 0 and line.new_fq2 in file_list:
            raise Exception(
                "Identical fastq file paths created in samples table after processing: " +
                str(line.new_fq2) + "; this means that names only differed in their " +
                "special characters, or were already identical beforehand. Please fix manually."
            )
        sample_units.append(( sample, line.unit ))
        file_list.append(line.new_fq1)
        if len(line.new_fq2) > 0:
            file_list.append(line.new_fq2)

    print(colored(
        "Table contains " + str(len(sample_units)) + " lines (samples+units) with " +
         str(len(file_list)) + " fastq files.", "green"
    ))
    if invalid_samples > 0:
        print(colored(
            "Out of these, " + str(invalid_samples) + " sample names contain invalid characters.",
            "This might cause trouble when using grenepipe with these files. "
            "Please consider to use the `--clean` option to fix these sample names.", "red"
        ))
    if invalid_files > 0:
        print(colored(
            "Out of these, " + str(invalid_files) + " fastq files contain invalid characters.",
            "This might cause trouble when using grenepipe with these files. "
            "Please consider to use the `--clean` option to fix these file names.", "red"
        ))
    return table

def i_like_to_move_it( table, args ):
    """Do the actual work of copying (or linking) the files."""

    # Find sum of file sizes that we are above to process. Could be done in the loop of the name
    # processing already, but let's keep the functionality separate here.
    # We use file sizes instead of just count of files, as it's nicer and more precise.
    bytes = 0
    files = 0
    for line in table:
        bytes += os.path.getsize( line.old_fq1 )
        files += 1
        if len(line.new_fq2) > 0:
            bytes += os.path.getsize( line.old_fq2 )
            files += 1

    # Make sure that we want to do this, when dealing with large files > ~1GB total.
    print(
        "About to " + args.mode + " " + str(files) + " fastq files with a total of " +
        file_size_human_readable( bytes ) + " to " + args.out_dir
    )
    if args.mode == "copy" and bytes > pow(10, 9) and not yes_or_no("Continue?"):
        sys.exit()

    # We are potentially doing a lot of work here, when copying. Let's keep users informed.
    # We use bytes for the copy, and file count for symlink, as this is way faster.
    if args.mode == "copy":
        pbar = progressbar.ProgressBar( max_value = bytes )
    elif args.mode == "link":
        pbar = progressbar.ProgressBar( max_value = files )
    else:
        raise Exception( "Invalid mode " + args.mode )
    pbar.start()

    # Do the copy/link
    os.makedirs(args.out_dir, exist_ok=True)
    for line in table:
        if args.mode == "copy":
            shutil.copyfile( line.old_fq1, line.new_fq1 )
            pbar += os.path.getsize( line.old_fq1 )
            if len(line.new_fq2) > 0:
                shutil.copyfile( line.old_fq2, line.new_fq2 )
                pbar += os.path.getsize( line.old_fq2 )
        elif args.mode == "link":
            os.symlink( line.old_fq1, line.new_fq1 )
            pbar += 1
            if len(line.new_fq2) > 0:
                os.symlink( line.old_fq2, line.new_fq2 )
                pbar += 1

    pbar.finish()
    print(colored("Finished", "green"))

def new_samples_table_path( args ):
    if args.out_samples_table:
        return args.out_samples_table
    head, tail = os.path.split(args.samples_table)
    parts = os.path.splitext(tail)
    if len(parts[0]) == 0:
        raise Exception( "Invalid input samples table path." )
    tail = parts[0] + "-copied" + parts[1]
    return os.path.join( head, tail )

def write_samples_table( table, target ):
    with open( target, 'w' ) as out:
        out.write("sample\tunit\tplatform\tfq1\tfq2\n")
        for line in table:
            out.write(
                line.new_name + "\t" + str(line.unit) + "\t" + line.platform + "\t" +
                line.new_fq1 + "\t" + line.new_fq2 + "\n"
            )

# =================================================================================================
#     Main function that actually does stuff
# =================================================================================================

if __name__ == "__main__":
    # Get the CLI options
    args = parser.parse_args()

    # Check that the out dir is actually valid itself.
    args.out_dir = os.path.abspath(args.out_dir)
    if not valid_filepath( args.out_dir ):
        if args.clean:
            raise Exception(
                "Cannot write cleaned fastq files to output directory, as the provided directory "
                "name itself already contains invalid characters."
            )
        else:
            print(colored(
                "The provided directory output directory name itself contains invalid characters. "
                "This might cause trouble when using grenepipe with these files. "
                "Please consider to use a directory that only contains save characters.", "red"
            ))

    # Output file check.
    args.out_samples_table = new_samples_table_path( args )
    if os.path.exists(args.out_samples_table):
        if not yes_or_no(
            "Output samples table `" + args.out_samples_table + "` exists. Do you want to overwrite?"
        ):
            sys.exit()

    # Read the table and process the names
    table = read_samples_table( args.samples_table )
    table = process_samples_table_names( table, args )
    write_samples_table( table, args.out_samples_table )
    i_like_to_move_it( table, args )
